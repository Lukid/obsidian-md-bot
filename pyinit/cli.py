#!/usr/bin/env python3
import os
import sys
import subprocess
import argparse

# Prova a importare rich per log colorati
try:
    from rich.console import Console
    from rich.progress import Progress
    console = Console()
except ImportError:
    console = None  # Se rich non √® installato, usa print normale

def log(message, status="INFO"):
    """Stampa messaggi colorati se rich √® disponibile, altrimenti usa print."""
    if console:
        status_map = {
            "INFO": "[blue]‚Ñπ INFO[/]",
            "SUCCESS": "[green]‚úî SUCCESS[/]",
            "ERROR": "[red]‚ùå ERROR[/]",
            "WARNING": "[yellow]‚ö† WARNING[/]",
        }
        console.print(f"{status_map.get(status, '[blue]‚Ñπ INFO[/]')} {message}")
    else:
        print(f"{status}: {message}")

def run_command(command, cwd=None):
    """Esegue un comando nella shell e gestisce gli errori."""
    try:
        subprocess.run(command, shell=True, cwd=cwd, check=True)
    except subprocess.CalledProcessError as e:
        log(f"Il comando '{e.cmd}' ha fallito con codice {e.returncode}.", "ERROR")
        sys.exit(1)

def is_poetry_installed():
    """Verifica se Poetry √® installato, globalmente o con pipx."""
    try:
        subprocess.run(["poetry", "--version"], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        return True
    except FileNotFoundError:
        return False

def create_project_structure(project_path):
    """Crea la struttura base del progetto con barra di avanzamento."""
    folders = ["src", "tests", "docs"]
    files = {
        "src/__init__.py": "",
        "src/main.py": '#!/usr/bin/env python3\n\ndef main():\n    print("Hello, world!")\n\nif __name__ == "__main__":\n    main()\n',
        "tests/__init__.py": "",
        ".gitignore": """# üî• Python .gitignore - Generated by PyInit

# Virtual Environment
venv/
.venv/
env/
pip-log.txt
pip-delete-this-directory.txt

# Bytecode files
__pycache__/
*.py[cod]

# Logs & Debugging
*.log
*.out
*.err

# IDE Configurations
.vscode/
.idea/
*.sublime-project
*.sublime-workspace

# macOS
.DS_Store

# Jupyter Notebook Checkpoints
.ipynb_checkpoints/

# MyPy Type Checking
.mypy_cache/

# PyTest Cache
.pytest_cache/

# Coverage Reports
htmlcov/
.coverage
.tox/

# Build Artifacts
build/
dist/
*.egg-info/
""",
        ".env": "# Variabili d'ambiente\n",
        "requirements.txt": "",
        "README.md": f"# {os.path.basename(project_path)}\n\nDescrizione del progetto.",
        "Makefile": """install:\n\tpython -m venv venv && venv/bin/pip install -r requirements.txt\n\nrun:\n\tvenv/bin/python src/main.py\n""",
        "setup.py": f"""from setuptools import setup, find_packages

setup(
    name="{os.path.basename(project_path)}",
    version="0.1",
    packages=find_packages(),
    install_requires=[],
    entry_points={{
        "console_scripts": [
            "{os.path.basename(project_path)}=src.main:main",
        ],
    }},
)
"""
    }

    if console:
        with Progress() as progress:
            task = progress.add_task("[cyan]üìÇ Creazione struttura progetto...", total=len(folders) + len(files))
            for folder in folders:
                os.makedirs(os.path.join(project_path, folder), exist_ok=True)
                progress.advance(task)
            for file, content in files.items():
                with open(os.path.join(project_path, file), "w") as f:
                    f.write(content)
                progress.advance(task)
    else:
        for folder in folders:
            os.makedirs(os.path.join(project_path, folder), exist_ok=True)
        for file, content in files.items():
            with open(os.path.join(project_path, file), "w") as f:
                f.write(content)

    log("Struttura progetto creata con successo.", "SUCCESS")


def setup_virtual_environment(project_path):
    """Create and configure a virtual environment with essential dependencies, suppressing pip logs."""
    log("üêç Setting up the virtual environment...")
    run_command("python3 -m venv venv", cwd=project_path)

    if console:
        with Progress() as progress:
            task = progress.add_task("[cyan]üì¶ Installing dependencies...", total=3)
            run_command("venv/bin/pip install --upgrade pip setuptools wheel -q", cwd=project_path)
            progress.advance(task)
            run_command("venv/bin/pip install pytest black -q", cwd=project_path)
            progress.advance(task)
            run_command("venv/bin/pip freeze > requirements.txt", cwd=project_path)
            progress.advance(task)
    else:
        run_command("venv/bin/pip install --upgrade pip setuptools wheel -q", cwd=project_path)
        run_command("venv/bin/pip install pytest black -q", cwd=project_path)
        run_command("venv/bin/pip freeze > requirements.txt", cwd=project_path)

    log("‚úÖ Virtual environment set up successfully!", "SUCCESS")

def setup_poetry_project(project_path):
    """Configures a project with Poetry, using pipx if necessary, and suppresses pip logs."""
    poetry_cmd = "poetry"

    if not is_poetry_installed():
        log("üì¶ Poetry not found. It will be executed using pipx.", "WARNING")
        poetry_cmd = "pipx run poetry"

    log("üì¶ Initializing a project with Poetry...")
    run_command(f"{poetry_cmd} init -n", cwd=project_path)
    run_command(f"{poetry_cmd} add pytest black -q", cwd=project_path)

def create_dockerfile(project_path):
    """Genera un Dockerfile per il progetto."""
    log("üê≥ Creazione del Dockerfile...")
    dockerfile_content = """FROM python:3.9
WORKDIR /app
COPY . .
RUN pip install -r requirements.txt
CMD ["python", "src/main.py"]
"""
    with open(os.path.join(project_path, "Dockerfile"), "w") as f:
        f.write(dockerfile_content)
    log("Dockerfile creato con successo.", "SUCCESS")

def main():
    """Gestisce l'interfaccia CLI con opzioni."""
    parser = argparse.ArgumentParser(description="Inizializza un nuovo progetto Python.")
    parser.add_argument("project_name", help="Nome del progetto")
    parser.add_argument("--poetry", action="store_true", help="Usa Poetry invece di venv")
    parser.add_argument("--docker", action="store_true", help="Crea un Dockerfile")

    args = parser.parse_args()
    project_name = args.project_name

    log(f"üöÄ Creazione del progetto `{project_name}` in corso...", "INFO")
    create_project_structure(project_name)

    if args.poetry:
        setup_poetry_project(project_name)
    else:
        setup_virtual_environment(project_name)

    if args.docker:
        create_dockerfile(project_name)

    log(f"‚úÖ Progetto `{project_name}` creato con successo!", "SUCCESS")

if __name__ == "__main__":
    main()
